package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

var versionRegex = regexp.MustCompile(`version (\d+\.\d+\.\d+\.\d+)`)

type stmtWork struct {
	testDir    string
	testName   string
	stmtNum    int
	stmt       string
	outputPath string
}

type testResult struct {
	testDir   string
	stmtNum   int
	success   bool
	hasOutput bool
}

func main() {
	testName := flag.String("test", "", "Single test directory name to process (if empty, process all)")
	clickhouseBin := flag.String("bin", "./clickhouse", "Path to ClickHouse binary")
	dryRun := flag.Bool("dry-run", false, "Print statements without executing")
	workers := flag.Int("workers", runtime.NumCPU()*4, "Number of parallel workers")
	addVersionOnly := flag.Bool("add-version-only", false, "Only add version comment to existing files without regenerating")
	flag.Parse()

	// For add-version-only mode, we just need the version string
	if *addVersionOnly {
		version := getClickHouseVersion(*clickhouseBin)
		fmt.Printf("Adding version comment (ClickHouse %s) to existing explain files...\n", version)
		addVersionComments(version, *workers)
		return
	}

	// Check if clickhouse binary exists
	if !*dryRun {
		if _, err := os.Stat(*clickhouseBin); os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "ClickHouse binary not found at %s\n", *clickhouseBin)
			fmt.Fprintf(os.Stderr, "Run: ./scripts/clickhouse.sh download\n")
			os.Exit(1)
		}
	}

	// Get ClickHouse version
	version := getClickHouseVersion(*clickhouseBin)
	fmt.Printf("Using ClickHouse version: %s (workers: %d)\n", version, *workers)

	testdataDir := "parser/testdata"

	if *testName != "" {
		// Process single test - use local mode for simplicity
		if err := processTestLocal(filepath.Join(testdataDir, *testName), *clickhouseBin, version, *dryRun); err != nil {
			fmt.Fprintf(os.Stderr, "Error processing %s: %v\n", *testName, err)
			os.Exit(1)
		}
		return
	}

	// Start ClickHouse server
	fmt.Println("Starting ClickHouse server...")
	server, err := startClickHouseServer(*clickhouseBin)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to start ClickHouse server: %v\n", err)
		os.Exit(1)
	}
	defer server.Stop()

	fmt.Printf("Server started on port %d\n", server.port)

	// Process all tests in parallel at statement level
	entries, err := os.ReadDir(testdataDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading testdata: %v\n", err)
		os.Exit(1)
	}

	// Collect all work items first
	var allWork []stmtWork
	testStmtCounts := make(map[string]int)

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		testDir := filepath.Join(testdataDir, entry.Name())
		queryPath := filepath.Join(testDir, "query.sql")
		queryBytes, err := os.ReadFile(queryPath)
		if err != nil {
			continue
		}

		statements := splitStatements(string(queryBytes))
		if len(statements) == 0 {
			continue
		}

		testStmtCounts[testDir] = len(statements)

		for i, stmt := range statements {
			stmtNum := i + 1
			var outputPath string
			if stmtNum == 1 {
				outputPath = filepath.Join(testDir, "explain.txt")
			} else {
				outputPath = filepath.Join(testDir, fmt.Sprintf("explain_%d.txt", stmtNum))
			}
			allWork = append(allWork, stmtWork{
				testDir:    testDir,
				testName:   entry.Name(),
				stmtNum:    stmtNum,
				stmt:       stmt,
				outputPath: outputPath,
			})
		}
	}

	fmt.Printf("Processing %d statements from %d tests...\n", len(allWork), len(testStmtCounts))

	// Create work and result channels
	work := make(chan stmtWork, len(allWork))
	results := make(chan testResult, len(allWork))

	// Start workers
	var wg sync.WaitGroup
	for i := 0; i < *workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for item := range work {
				if *dryRun {
					fmt.Printf("[%s] stmt%d: %s\n", item.testName, item.stmtNum, truncate(item.stmt, 60))
					results <- testResult{testDir: item.testDir, stmtNum: item.stmtNum, success: true, hasOutput: false}
					continue
				}

				explain, err := server.ExplainAST(item.stmt)
				if err != nil {
					results <- testResult{testDir: item.testDir, stmtNum: item.stmtNum, success: false, hasOutput: false}
					continue
				}

				content := fmt.Sprintf("-- Generated by ClickHouse %s\n%s\n", version, explain)
				if err := os.WriteFile(item.outputPath, []byte(content), 0644); err != nil {
					results <- testResult{testDir: item.testDir, stmtNum: item.stmtNum, success: false, hasOutput: false}
					continue
				}
				results <- testResult{testDir: item.testDir, stmtNum: item.stmtNum, success: true, hasOutput: true}
			}
		}()
	}

	// Send all work
	for _, w := range allWork {
		work <- w
	}
	close(work)

	// Collect results in background
	go func() {
		wg.Wait()
		close(results)
	}()

	// Track results per test
	testResults := make(map[string]map[int]bool)
	var processed, failed int64

	for r := range results {
		if testResults[r.testDir] == nil {
			testResults[r.testDir] = make(map[int]bool)
		}
		testResults[r.testDir][r.stmtNum] = r.success
		if r.success && r.hasOutput {
			atomic.AddInt64(&processed, 1)
		} else if !r.success {
			atomic.AddInt64(&failed, 1)
		}
	}

	// Update metadata.json for each test
	var testsOK, testsFailed int64
	for testDir, stmtResults := range testResults {
		allSuccess := true
		for _, success := range stmtResults {
			if !success {
				allSuccess = false
				break
			}
		}

		metadataPath := filepath.Join(testDir, "metadata.json")
		if allSuccess {
			if err := os.WriteFile(metadataPath, []byte("{}\n"), 0644); err != nil {
				fmt.Fprintf(os.Stderr, "Error writing %s: %v\n", metadataPath, err)
			}
			atomic.AddInt64(&testsOK, 1)
		} else {
			atomic.AddInt64(&testsFailed, 1)
		}
	}

	fmt.Printf("\nStatements: %d processed, %d failed\n", processed, failed)
	fmt.Printf("Tests: %d OK, %d with failures\n", testsOK, testsFailed)
}

// ClickHouseServer manages a running ClickHouse server instance
type ClickHouseServer struct {
	cmd     *exec.Cmd
	port    int
	dataDir string
	binPath string
}

func startClickHouseServer(binPath string) (*ClickHouseServer, error) {
	// Create temp directory for server data
	dataDir, err := os.MkdirTemp("", "clickhouse-data-*")
	if err != nil {
		return nil, fmt.Errorf("creating temp dir: %w", err)
	}

	port := 19000 // Use non-standard port to avoid conflicts

	// Start server
	cmd := exec.Command(binPath, "server",
		"--",
		fmt.Sprintf("--tcp_port=%d", port),
		fmt.Sprintf("--path=%s", dataDir),
		"--listen_host=127.0.0.1",
		"--log_level=error",
	)

	// Capture stderr for debugging
	stderrPipe, _ := cmd.StderrPipe()

	if err := cmd.Start(); err != nil {
		os.RemoveAll(dataDir)
		return nil, fmt.Errorf("starting server: %w", err)
	}

	// Drain stderr in background
	go func() {
		io.Copy(io.Discard, stderrPipe)
	}()

	server := &ClickHouseServer{
		cmd:     cmd,
		port:    port,
		dataDir: dataDir,
		binPath: binPath,
	}

	// Wait for server to be ready
	if err := server.waitReady(30 * time.Second); err != nil {
		server.Stop()
		return nil, fmt.Errorf("waiting for server: %w", err)
	}

	return server, nil
}

func (s *ClickHouseServer) waitReady(timeout time.Duration) error {
	deadline := time.Now().Add(timeout)
	for time.Now().Before(deadline) {
		cmd := exec.Command(s.binPath, "client",
			"--host=127.0.0.1",
			fmt.Sprintf("--port=%d", s.port),
			"--query=SELECT 1",
		)
		if err := cmd.Run(); err == nil {
			return nil
		}
		time.Sleep(100 * time.Millisecond)
	}
	return fmt.Errorf("server not ready after %v", timeout)
}

func (s *ClickHouseServer) ExplainAST(stmt string) (string, error) {
	query := fmt.Sprintf("EXPLAIN AST %s", stmt)
	cmd := exec.Command(s.binPath, "client",
		"--host=127.0.0.1",
		fmt.Sprintf("--port=%d", s.port),
		fmt.Sprintf("--query=%s", query),
	)

	output, err := cmd.Output()
	if err != nil {
		return "", err
	}

	return strings.TrimSpace(string(output)), nil
}

func (s *ClickHouseServer) Stop() {
	if s.cmd != nil && s.cmd.Process != nil {
		s.cmd.Process.Kill()
		s.cmd.Wait()
	}
	if s.dataDir != "" {
		os.RemoveAll(s.dataDir)
	}
}

func getClickHouseVersion(clickhouseBin string) string {
	cmd := exec.Command(clickhouseBin, "--version")
	output, err := cmd.Output()
	if err != nil {
		return "unknown"
	}
	matches := versionRegex.FindStringSubmatch(string(output))
	if len(matches) >= 2 {
		return matches[1]
	}
	return "unknown"
}

// processTestLocal processes a single test directory using clickhouse local
func processTestLocal(testDir, clickhouseBin, version string, dryRun bool) error {
	queryPath := filepath.Join(testDir, "query.sql")
	queryBytes, err := os.ReadFile(queryPath)
	if err != nil {
		return fmt.Errorf("reading query.sql: %w", err)
	}

	statements := splitStatements(string(queryBytes))
	if len(statements) == 0 {
		return fmt.Errorf("no statements found")
	}

	testName := filepath.Base(testDir)
	allSuccess := true

	for i, stmt := range statements {
		stmtNum := i + 1
		if dryRun {
			fmt.Printf("[%s] stmt%d: %s\n", testName, stmtNum, truncate(stmt, 60))
			continue
		}

		explain, err := explainASTLocal(clickhouseBin, stmt)
		if err != nil {
			allSuccess = false
			continue
		}

		var outputPath string
		if stmtNum == 1 {
			outputPath = filepath.Join(testDir, "explain.txt")
		} else {
			outputPath = filepath.Join(testDir, fmt.Sprintf("explain_%d.txt", stmtNum))
		}

		content := fmt.Sprintf("-- Generated by ClickHouse %s\n%s\n", version, explain)
		if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
			return fmt.Errorf("writing %s: %w", outputPath, err)
		}
	}

	metadataPath := filepath.Join(testDir, "metadata.json")
	if allSuccess {
		if err := os.WriteFile(metadataPath, []byte("{}\n"), 0644); err != nil {
			return fmt.Errorf("writing metadata.json: %w", err)
		}
	}

	fmt.Printf("[%s] OK (%d statements)\n", testName, len(statements))
	return nil
}

func explainASTLocal(clickhouseBin, stmt string) (string, error) {
	query := fmt.Sprintf("EXPLAIN AST %s", stmt)
	cmd := exec.Command(clickhouseBin, "local", "--query", query)
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(output)), nil
}

func splitStatements(content string) []string {
	var statements []string
	var current strings.Builder

	scanner := bufio.NewScanner(strings.NewReader(content))
	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		if trimmed == "" || strings.HasPrefix(trimmed, "--") {
			continue
		}

		if idx := findCommentStart(trimmed); idx >= 0 {
			trimmed = strings.TrimSpace(trimmed[:idx])
			if trimmed == "" {
				continue
			}
		}

		if current.Len() > 0 {
			current.WriteString(" ")
		}
		current.WriteString(trimmed)

		if strings.HasSuffix(trimmed, ";") {
			stmt := strings.TrimSpace(current.String())
			stmt = strings.TrimSuffix(stmt, ";")
			if stmt != "" {
				statements = append(statements, stmt)
			}
			current.Reset()
		}
	}

	if current.Len() > 0 {
		stmt := strings.TrimSpace(current.String())
		stmt = strings.TrimSuffix(stmt, ";")
		if stmt != "" {
			statements = append(statements, stmt)
		}
	}

	return statements
}

func findCommentStart(line string) int {
	inString := false
	var stringChar byte
	for i := 0; i < len(line); i++ {
		c := line[i]
		if inString {
			if c == '\\' && i+1 < len(line) {
				i++
				continue
			}
			if c == stringChar {
				inString = false
			}
		} else {
			if c == '\'' || c == '"' || c == '`' {
				inString = true
				stringChar = c
			} else if c == '-' && i+1 < len(line) && line[i+1] == '-' {
				if i+2 >= len(line) || line[i+2] == ' ' || line[i+2] == '\t' {
					return i
				}
			}
		}
	}
	return -1
}

func truncate(s string, n int) string {
	s = strings.ReplaceAll(s, "\n", " ")
	s = strings.Join(strings.Fields(s), " ")
	if len(s) <= n {
		return s
	}
	return s[:n-3] + "..."
}

func addVersionComments(version string, workers int) {
	testdataDir := "parser/testdata"
	entries, err := os.ReadDir(testdataDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading testdata: %v\n", err)
		os.Exit(1)
	}

	type workItem struct {
		filePath string
	}
	work := make(chan workItem, 100000)

	var processed, skipped int64
	var wg sync.WaitGroup

	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			versionComment := fmt.Sprintf("-- Generated by ClickHouse %s\n", version)
			for item := range work {
				content, err := os.ReadFile(item.filePath)
				if err != nil {
					atomic.AddInt64(&skipped, 1)
					continue
				}

				if strings.HasPrefix(string(content), "-- Generated by ClickHouse") {
					atomic.AddInt64(&skipped, 1)
					continue
				}

				newContent := versionComment + string(content)
				if err := os.WriteFile(item.filePath, []byte(newContent), 0644); err != nil {
					fmt.Fprintf(os.Stderr, "Error writing %s: %v\n", item.filePath, err)
					continue
				}
				atomic.AddInt64(&processed, 1)
			}
		}()
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		testDir := filepath.Join(testdataDir, entry.Name())
		files, _ := filepath.Glob(filepath.Join(testDir, "explain*.txt"))
		for _, f := range files {
			work <- workItem{filePath: f}
		}
	}
	close(work)

	wg.Wait()
	fmt.Printf("\nProcessed: %d, Skipped (already has version): %d\n", processed, skipped)
}
